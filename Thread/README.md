# Java 并发

## 创建线程的三种方法

>小结： 使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set
>方法设置参数或者通过构造函数进行传递，而如果使用Runnable 方式，则只能使用主线
>程里面被声明为final 的变量。不好的地方是Java 不支持多继承，如果继承了Thread 类，
>那么子类不能再继承其他类，而Runable 则没有这个限制。前两种方式都没办法拿到任务
>的返回结果，但是Futuretask 方式可以。

## 通知和等待

> notify()和notifyAll()
> wait()

## sleep和join

### **sleep**

+ 内容

### **join**

+ 内容

### **yield**

+ 内容

>总结： sleep 与yield 方法的区别在于，当线程调用sleep 方法时调用线程会被阻塞挂
>起指定的时间，在这期间线程调度器不会去调度该线程。而调用yield 方法时，线程只是
>让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度
>时就有可能调度到当前线程执行。

## 线程中断

+ **内容**
Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行， 而是被中断的线程根据中断状态自行处理。

## 线程死锁

+ 考虑死锁代码中满足的条件

> Thread-0 是线程A , Thread-1 是线程B ，代码首先创建了两个
资源， 并创建了两个线程。从输出结果可以知道， 线程调度器先调度了线程A ， 也就是把
CPU 资源分配给了线程A，线程A 使用synchronized( resourceA ） 方法获取到了resourceA
的监视器锁，然后调用s l eep 函数休眠ls ，休眠l s 是为了保证线程A 在获取resourceB 对
应的锁前让线程B 抢占到CPU ， 获取到资源resourceB 上的锁。线程A 调用s l eep 方法后
线程B 会执行synclu・onized(resourc eB） 方法，这代表线程B 获取到了res ourceB 对象的监
视器锁资源， 然后调用sle叩函数休眠l s 。好了，到了这里线程A 获取到了resourceA 资
源， 线程B 获取到了res o urceB 资源。线程A 休眠结束后会企图获取re s ourceB 资源， 而
resourceB 资源被线程B 所持有， 所以线程A 会被阻塞而等待。而同时线程B 休眠结束后
会企图获取resourceA 资源， 而res ourceA 资源己经被线程A 持有，所以线程A 和线程B
就陷入了相互等待的状态， 也就产生了死锁

+ resourc eA 和re sourc eB 都是**互斥资源**
+ 线程A 首先通过synchroni zed(resourceA） 方法获取到resourceA 上的监视器锁资源，
然后通过synclu・oni zed(resourceB） 方法等待获取resourceB 上的监视器锁资源， 这就构成了
**请求并持有条件**。
+ 线程A 在获取resourceA 上的监视器锁资源后， 该资源不会被线程B 掠夺走， 只有线
程A 自己主动释放resourceA 资源时，它才会放弃对该资源的持有权，这构成了资源的**不可剥夺条件。**
+ 线程A 持有obj 巳ctA 资源并等待获取objectB 资源，而线程B 持有objectB 资源并等
待objectA 资源，这构成了**环路等待条件。**

## 避免线程死锁

+ **要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可**

    > 目前只有请求并持有和环路等待条件是可以被破坏的。

1. 资源的有序分配

## 守护线程与用户线程

*Java 中的线程分为两类，分别为daemon 线程（守护线程〉和user 线程（用户线程）。*

+ 在NM 启动时会调用main 函数， main 函数所在的钱程就是一个用户线程，其实在NM
内部同时－还启动了好多守护线程， 比如垃圾回收线程。

+ 区别
  + 当最后一个非守护线程结束时， NM 会正常退出，而不管当前是否有守护线程，也就是说守护线程是否结束并不影响NM 的退出。言外之意，只要有一个用
    户线程还没结束， 正常情况下NM 就不会退出。