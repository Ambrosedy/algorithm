# 内存可见性解决方案

## NoSafe
+ 这是一个基本类，线程不安全

## synchronized

+ 独占锁
+ 同时只有一个线程能够调用get() 方法，其他线程调用会被阻塞
+ 有上下文切换和线程重新调度的开销

## volatile

+ 非阻塞算法，不会造成线程上下文切换的开销。

## 

> 在这里使用synchroni zed 和使用volatile 是等价的，都解决了共享变量value 的内存可
  见性问题;
> 但并非在所有情况下使用它们都是等价的， volatil e 虽然提供了可见性保证，但并不
  保证操作的原子性。

## 那么一般在什么时候才使用volatile 关键字呢？

+ 写入变量值不依赖、变量的当前值时。因为如果依赖当前值，将是获取一计算一写入
  三步操作，这三步操作不是原子性的，而volatile 不保证原子性。

+ 读写变量值时没有加锁。因为加锁本身已经保证了内存可见性，这时候不需要把变
  量声明为vo latile 的。